<!doctype html public "-//W3C//DTD HTML 4.0 Frameset//EN""http://www.w3.org/TR/REC-html40/frameset.dtd">
<html>
<head>
<title>
Jala 1.0 Overview
</title>
<link rel ="stylesheet" type="text/css" href="stylesheet.css" title="Style">
<script>
function asd() {
	
		parent.document.title="IndexManager.js Overview";
	
}
</script>
</head>
<body bgcolor="white" onload="asd();">

<!-- ========== START OF NAVBAR ========== -->
<a name="navbar_top"><!-- --></a>
<table border="0" width="100%" cellpadding="1" cellspacing="0">
<tr>
<td colspan=2 bgcolor="#EEEEFF" class="NavBarCell1">
<a name="navbar_top_firstrow"><!-- --></a>
<table border="0" cellpadding="0" cellspacing="3">
  <tr align="center" valign="top">
  
  
  <td bgcolor="#EEEEFF" class="NavBarCell1">    <a href="overview-summary.html"><font class="NavBarFont1"><b>Overview</b></font></a>&nbsp;</td>
  <td bgcolor="#FFFFFF" class="NavBarCell1Rev">	&nbsp;<font class="NavBarFont1Rev"><b>File</b></font>&nbsp;</td>
  

  <td bgcolor="#FFFFFF" class="NavBarCell1"> 	<font class="NavBarFont1">Class</font>&nbsp;</td>
  <td bgcolor="#EEEEFF" class="NavBarCell1">    <a href="overview-tree.html"><font class="NavBarFont1"><b>Tree</b></font></a>&nbsp;</td>
  <td bgcolor="#EEEEFF" class="NavBarCell1">    <a href="index-all.html"--><font class="NavBarFont1"><b>Index</b></font></a>&nbsp;</td>
  <td bgcolor="#EEEEFF" class="NavBarCell1">    <a href="help-doc.html"><font class="NavBarFont1"><b>Help</b></font></a>&nbsp;</td>
  </tr>
</table>
</td>
<td bgcolor="#EEEEFF" align="right" valign="top">
<em>
<b>Jala 1.0</b></em>
</td>
</tr>

<tr>
<td bgcolor="white" class="NavBarCell2"><font size="-2">
&nbsp;PREV&nbsp;
&nbsp;NEXT</font></td>
<td bgcolor="white" class="NavBarCell2"><font size="-2">
  <a href="index.html" target="_top"><b>FRAMES</b></a>  &nbsp;
&nbsp;<a href="overview-summary.html" target="_top"><b>NO FRAMES</b></a>
&nbsp;&nbsp;
<script>
  <!--
  if(window==top) {
    document.writeln('<A HREF="allclasses-noframe.html" TARGET=""><B>All Classes</B></A>');
  }
  //-->
</script>
<noscript>
<a href="allclasses-noframe.html" target=""><b>All Classes</b></a>
</noscript>
</font></td>
</tr>
</table>
<!-- =========== END OF NAVBAR =========== -->

<hr>
<center>
	
	   <h2>IndexManager.js</h2>
	
</center>

	


<h4>Summary</h4>
<p>
	
		Fields and methods of the jala.IndexManager class.<BR/><BR/>
	
</p>

<hr>


    <table border="1" cellpadding="3" cellspacing="0" width="100%">
    <tr bgcolor="#CCCCFF" class="TableHeadingColor">
    <td colspan=2><font size="+2">
    
        <b>Class Summary</b>
    
    </font></td>
    </tr>
    
    <tr bgcolor="white" class="TableRowColor">
    <td width="15%"><b><a href="jala.IndexManager.html">jala.IndexManager</a></b></td>
    <td>This class basically sits on top of a helma.Search.Index instance
 and provides methods for adding, removing, optimizing and rebuilding
 the underlying index.</td>
    </tr>
    
    <tr bgcolor="white" class="TableRowColor">
    <td width="15%"><b><a href="jala.IndexManager.Job.html">jala.IndexManager.Job</a></b></td>
    <td>Instances of this class represent a single index
 manipulation job to be processed by the index manager.</td>
    </tr>
    
    </table>
    <hr/> 


<!-- ========== METHOD SUMMARY =========== -->

<!-- ========== END METHOD SUMMARY =========== -->


        <pre class="sourceview"><span class="comment">//</span>
<span class="comment">// Jala Project [http://opensvn.csie.org/traccgi/jala]</span>
<span class="comment">//</span>
<span class="comment">// Copyright 2004 ORF Online und Teletext GmbH</span>
<span class="comment">//</span>
<span class="comment">// Licensed under the Apache License, Version 2.0 (the ``License'');</span>
<span class="comment">// you may not use this file except in compliance with the License.</span>
<span class="comment">// You may obtain a copy of the License at</span>
<span class="comment">//</span>
<span class="comment">//    http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="comment">//</span>
<span class="comment">// Unless required by applicable law or agreed to in writing, software</span>
<span class="comment">// distributed under the License is distributed on an ``AS IS'' BASIS,</span>
<span class="comment">// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="comment">// See the License for the specific language governing permissions and</span>
<span class="comment">// limitations under the License.</span>
<span class="comment">//</span>
<span class="comment">// $Revision$</span>
<span class="comment">// $LastChangedBy$</span>
<span class="comment">// $LastChangedDate$</span>
<span class="comment">// $HeadURL$</span>
<span class="comment">//</span>


<span class="comment">/**
 * <span class="attrib">@fileoverview</span> Fields and methods of the jala.IndexManager class.
 */</span>


<span class="comment">// Define the global namespace for Jala modules</span>
<span class="reserved">if</span> (!global.jala) {
   global.jala = {};
}


<span class="comment">/**
 * HelmaLib dependencies
 */</span>
app.addRepository(<span class="literal">"modules/helma/Search.js"</span>);

<span class="comment">/**
 * Jala dependencies
 */</span>
app.addRepository(<span class="literal">"modules/jala/code/AsyncRequest.js"</span>);

<span class="comment">/**
 * Constructs a new IndexManager object.
 * <span class="attrib">@class</span> This class basically sits on top of a helma.Search.Index instance
 * and provides methods for adding, removing, optimizing and rebuilding
 * the underlying index. All methods except rebuilding are executed
 * asynchronously using an internal queue that contains jobs created
 * for each call of add/remove/optimize. Rebuilding is somehow different
 * as it puts this manager into rebuilding mode where all following
 * calls of add/remove/optimize are queued, but the queue is not flushed
 * until rebuilding has finished. This ensures that objects that have been
 * modified during a rebuilding process are re-indexed properly afterwards.
 * <span class="attrib">@param</span> {String} name The name of the index, which is the name of the directory
 * the index already resides or will be created in.
 * <span class="attrib">@param</span> {helma.File} dir The base directory where this index's directory
 * is already existing or will be created in.
 * <span class="attrib">@param</span> {String} lang The language of the documents in this index. This leads
 * to the proper Lucene analyzer being used for indexing documents.
 * <span class="attrib">@constructor</span>
 * <span class="attrib">@see</span> helma.Search.createIndex
 */</span>
jala.IndexManager = <span class="reserved">function</span>(name, dir, lang) {
   <span class="comment">/**
    * Private variable containing the index managed by
    * this IndexManager instance.
    * <span class="attrib">@private</span> 
    */</span>
   var index = null;

   <span class="comment">/**
    * Private variable containing a status indicator.
    * <span class="attrib">@type</span> Number
    * <span class="attrib">@private</span>
    */</span>
   var status = jala.IndexManager.NORMAL;

   <span class="comment">/**
    * Synchronized linked list that functions as a queue for
    * asynchronous processing of index manipulation jobs.
    * <span class="attrib">@type</span> java.util.LinkedList
    * <span class="attrib">@private</span>
    * <span class="attrib">@see</span> jala.IndexManager.Job
    */</span>
   var queue = java.util.Collections.synchronizedList(new java.util.LinkedList());

   <span class="comment">/**
    * Private variable containing the worker flushing the queue
    * <span class="attrib">@type</span> jala.AsyncRequest
    * <span class="attrib">@private</span>
    */</span>
   var worker = null;

   <span class="comment">/**
    * Private property holding the version number of the underlying index
    * (see org.apache.lucene.index.IndexReader.getCurrentVersion()).
    * This is used to determine if the index should be optimized.
    * <span class="attrib">@type</span> Number
    * <span class="attrib">@private</span>
    * <span class="attrib">@see</span> #needsOptimize
    */</span>
   var version = 0;

   <span class="comment">/**
    * Returns the underlying index.
    * <span class="attrib">@returns</span> The index this queue is working on.
    * <span class="attrib">@type</span> helma.Search.Index
    */</span>
   <span class="reserved">this</span>.getIndex = <span class="reserved">function</span>() {
      <span class="reserved">return</span> index;
   };

   <span class="comment">/**
    * Returns the current version of this index manager
    * <span class="attrib">@returns</span> The current version of this index manager
    * <span class="attrib">@type</span> Number 
    */</span>
   <span class="reserved">this</span>.getVersion = <span class="reserved">function</span>() {
      <span class="reserved">return</span> version;
   };

   <span class="comment">/**
    * Returns the status of this manager.
    * <span class="attrib">@returns</span> The status of this index manager.
    * <span class="attrib">@type</span> Number
    * <span class="attrib">@see</span> #NORMAL
    * <span class="attrib">@see</span> #REBUILDING
    */</span>
   <span class="reserved">this</span>.getStatus = <span class="reserved">function</span>() {
      <span class="reserved">return</span> status;
   };

   <span class="comment">/**
    * Modifies the status of this manager, which has implications
    * on how index modifying jobs are handled. If the status
    * is {<span class="attrib">@link</span> #REBUILDING}, all jobs are queued until the status
    * is set back to {<span class="attrib">@link</span> #NORMAL}.
    * <span class="attrib">@param</span> {Number} s The new status of this manager.
    * <span class="attrib">@see</span> #NORMAL
    * <span class="attrib">@see</span> #REBUILDING
    */</span>
   <span class="reserved">this</span>.setStatus = <span class="reserved">function</span>(s) {
      status = s;
      <span class="reserved">return</span>;
   };

   <span class="comment">/**
    * Returns the queue this index manager is using.
    * <span class="attrib">@returns</span> The queue.
    * <span class="attrib">@type</span> java.util.LinkedList
    */</span>
   <span class="reserved">this</span>.getQueue = <span class="reserved">function</span>() {
      <span class="reserved">return</span> queue;
   };

   <span class="comment">/**
    * Returns the name of the index manger, which
    * is equal to the name of the underlying index
    * <span class="attrib">@returns</span> The name of the index manager
    * <span class="attrib">@type</span> String
    */</span>
   <span class="reserved">this</span>.getName = <span class="reserved">function</span>() {
      <span class="reserved">return</span> name;
   };

   <span class="comment">/**
    * Returns true if the underlying index is currently optimized.
    * <span class="attrib">@returns</span> True in case the index is optimized, false otherwise.
    * <span class="attrib">@type</span> Boolean
    */</span>
   <span class="reserved">this</span>.hasOptimizingJob = <span class="reserved">function</span>() {
      <span class="reserved">for</span> (var i=0; i&lt;queue.size(); i++) {
         <span class="reserved">if</span> (queue.get(i).type == jala.IndexManager.Job.OPTIMIZE) {
            <span class="reserved">return</span> true;
         }
      }
      <span class="reserved">return</span> false;
   };

   <span class="comment">/**
    * Returns true if a worker has been initialized and it's still alive.
    * <span class="attrib">@returns</span> True if a worker is running, false otherwise.
    * <span class="attrib">@type</span> Boolean
    */</span>
   <span class="reserved">this</span>.hasWorker = <span class="reserved">function</span>() {
      <span class="reserved">return</span> (worker != null) ? worker.isAlive() : false;
   };
   
   <span class="comment">/**
    * Returns true if the underlying index is currently rebuilding.
    * <span class="attrib">@returns</span> True in case the index is rebuilding, false otherwise.
    * <span class="attrib">@type</span> Boolean
    */</span>
   <span class="reserved">this</span>.isRebuilding = <span class="reserved">function</span>() {
      <span class="reserved">return</span> status == jala.IndexManager.REBUILDING;
   };

   <span class="comment">/**
    * Updates the internal version property of this index manager
    * to the current version of the underlying index.
    */</span>
   <span class="reserved">this</span>.updateVersion = <span class="reserved">function</span>() {
      version = <span class="reserved">this</span>.getCurrentIndexVersion();
      <span class="reserved">return</span>;
   };

   <span class="comment">/**
    * Starts a new worker thread if there isn't already one
    * processing the queue. This method also checks if the
    * thread is actually dead.
    * <span class="attrib">@param</span> {Boolean} force If true the worker is created regardless
    * whether there is one already or not.
    * <span class="attrib">@private</span>
    */</span>
   <span class="reserved">this</span>.startWorker = <span class="reserved">function</span>(force) {
      <span class="reserved">if</span> (force === true || !<span class="reserved">this</span>.hasWorker()) {
         app.logger.debug(<span class="literal">"IndexManager '"</span> + <span class="reserved">this</span>.getName() +
                          <span class="literal">"': creating new worker"</span>);
         worker = new jala.AsyncRequest(<span class="reserved">this</span>, <span class="literal">"flush"</span>);
         worker.evaluate();
      }
      <span class="reserved">return</span>;
   };
   
   <span class="comment">/**
    * Main constructor body. Initializes the underlying index.
    */</span>
   var search = new helma.Search();
   var analyzer = helma.Search.getAnalyzer(lang);
   var fsDir = search.getDirectory(new helma.File(dir, name));
   index = search.createIndex(fsDir, analyzer);
   <span class="comment">// initialize the version</span>
   <span class="reserved">this</span>.updateVersion();
   app.logger.info(<span class="literal">"IndexManager '"</span> + <span class="reserved">this</span>.getName() +
                   <span class="literal">"': created/mounted "</span> + index);

   <span class="reserved">return</span> <span class="reserved">this</span>;
};

<span class="comment">/**
 * Constant defining the maximum number of tries to add/remove
 * an object to/from the underlying index.
 * <span class="attrib">@type</span> Number
 * <span class="attrib">@final</span>
 */</span>
jala.IndexManager.MAXTRIES = 10;

<span class="comment">/**
 * Constant defining the number of changes in the underlying
 * index before it should be optimized.
 * <span class="attrib">@type</span> Number
 * <span class="attrib">@final</span>
 */</span>
jala.IndexManager.OPTIMIZE_INTERVAL = 1000;

<span class="comment">/**
 * Constant defining normal mode of this index manager.
 * <span class="attrib">@type</span> Number
 * <span class="attrib">@final</span>
 */</span>
jala.IndexManager.NORMAL = 1;

<span class="comment">/**
 * Constant defining rebuilding mode of this index manager.
 * <span class="attrib">@type</span> Number
 * <span class="attrib">@final</span>
 */</span>
jala.IndexManager.REBUILDING = 2;

<span class="comment">/**
 * Static helper method that returns the value of the "id"
 * field of a document object.
 * <span class="attrib">@param</span> {helma.Search.Document} doc The document whose id
 * should be returned.
 * <span class="attrib">@private</span>
 */</span>
jala.IndexManager.getDocumentId = <span class="reserved">function</span>(doc) {
   try {
      <span class="reserved">return</span> doc.getField(<span class="literal">"id"</span>).value;
   } catch (e) {
      <span class="comment">// ignore</span>
   }
   <span class="reserved">return</span> null;
};

<span class="comment">/**
 * Returns the milliseconds elapsed between the current timestamp
 * and the one passed as argument.
 * <span class="attrib">@returns</span> The elapsed time in millis.
 * <span class="attrib">@type</span> Number
 * <span class="attrib">@private</span>
 */</span>
jala.IndexManager.getRuntime = <span class="reserved">function</span>(d) {
   <span class="reserved">return</span> (new Date()) - d;
};

<span class="comment">/**
 * Returns an Array containing objects, where each one
 * contains information about an index segment in two
 * properties: "name" is the file name of the segment,
 * and "docCount" contains the number of documents in
 * this segment.
 * <span class="attrib">@returns</span> An Array containing segment informations.
 * <span class="attrib">@type</span> Array
 */</span>
jala.IndexManager.<span class="reserved">prototype</span>.getSegmentInfos = <span class="reserved">function</span>() {
   var FORMAT = -1;
   var infos = [];
   var directory = <span class="reserved">this</span>.getIndex().getDirectory();
   var input = directory.openInput(<span class="literal">"segments"</span>);
   var format, version, counter;

   try {
      format = input.readInt();
      <span class="reserved">if</span> (format &lt; 0){     <span class="comment">// file contains explicit format info</span>
         <span class="comment">// check that it is a format we can understand</span>
         <span class="reserved">if</span> (format &lt; FORMAT)
            throw (<span class="literal">"Unknown format version: "</span> + format);
         version = input.readLong(); <span class="comment">// read version</span>
         counter = input.readInt(); <span class="comment">// read counter</span>
      } <span class="reserved">else</span> {     <span class="comment">// file is in old format without explicit format info</span>
         counter = format;
      }
   
      <span class="reserved">for</span> (var i=input.readInt(); i&gt;0; i--) { <span class="comment">// read segmentInfos</span>
         infos.push({name: input.readString(),
                     docCount: input.readInt()});
      }
   
      <span class="reserved">if</span> (format &gt;= 0) {    <span class="comment">// in old format the version number may be at the end of the file</span>
         <span class="reserved">if</span> (input.getFilePointer() &gt;= input.length())
            version = 0; <span class="comment">// old file format without version number</span>
         <span class="reserved">else</span>
            version = input.readLong(); <span class="comment">// read version</span>
      }
   } catch (e) {
      app.logger.debug(<span class="literal">"Unable to retrieve segment infos, reason: "</span> + e);
   } finally {
      input.close();
   }
   <span class="reserved">return</span> infos;
};

<span class="comment">/** <span class="attrib">@ignore</span> */</span>
jala.IndexManager.<span class="reserved">prototype</span>.toString = <span class="reserved">function</span>() {
   var queue = <span class="reserved">this</span>.getQueue();
   <span class="reserved">return</span> <span class="literal">"[Index Manager '"</span> + <span class="reserved">this</span>.name + <span class="literal">"' ("</span> +
          queue.size() + <span class="literal">" objects queued)]"</span>;
};

<span class="comment">/**
 * Adds a HopObject to the underlying index. This is done
 * by adding a new job to the internal queue and starting
 * a new worker thread to process it (if there isn't already
 * a worker being busy processing the queue). Adding an object
 * to the index also means that all documents with the same Id will
 * be removed before. The HopObject must implement a method
 * &lt;code&gt;getIndexDocument&lt;/code&gt; that is expected to return
 * a ready-to-index instance of helma.Search.Document.
 * <span class="attrib">@param</span> {helma.Search.Document} doc The document object that should be
 * added to the underlying index.
 * <span class="attrib">@param</span> {Boolean} force (optional) If true the object will be added
 * instantly to the index without any check if the index is
 * locked or not, so use this option with caution. Normally this
 * option should never be set manually.
 * <span class="attrib">@see</span> helma.Search.Document
 */</span>
jala.IndexManager.<span class="reserved">prototype</span>.add = <span class="reserved">function</span>(doc, force) {
   <span class="reserved">if</span> (force === true) {
      var start = new Date();
      <span class="reserved">this</span>.getIndex().updateDocument(doc, <span class="literal">"id"</span>);
      app.logger.debug(<span class="literal">"IndexManager '"</span> + <span class="reserved">this</span>.getName() +
                       <span class="literal">"': added document with Id "</span> +
                       jala.IndexManager.getDocumentId(doc) +
                       <span class="literal">" in "</span> + jala.IndexManager.getRuntime(start) + <span class="literal">" ms"</span>);
   } <span class="reserved">else</span> {
      <span class="reserved">if</span> (!doc) {
         app.logger.error(<span class="literal">"IndexManager '"</span> + <span class="reserved">this</span>.getName() +
                          <span class="literal">"': missing document object to add"</span>);
      } <span class="reserved">else</span> {
         var job = new jala.IndexManager.Job(jala.IndexManager.Job.ADD,
                                             doc);
         <span class="reserved">this</span>.getQueue().add(job);
         app.logger.debug(<span class="literal">"IndexManager '"</span> + <span class="reserved">this</span>.getName() +
                          <span class="literal">"': queued adding document "</span> + job.getId() + <span class="literal">" to index"</span>);
         <span class="reserved">if</span> (!<span class="reserved">this</span>.isRebuilding()) {
            <span class="reserved">this</span>.startWorker();
         }
      }
   }
   <span class="reserved">return</span>;
};

<span class="comment">/**
 * Removes the object passed as argument from the underlying
 * index. The argument can be either a HopObject or a JavaScript
 * object, but this method expects the property &lt;code&gt;_id&lt;/code&gt;
 * to be set. Removing is done by adding a new job to the internal
 * queue, which in turn is processed asynchronously by a worker
 * thread.
 * <span class="attrib">@param</span> {HopObject | Object} obj The HopObject or JavaScript object
 * whose property &lt;code&gt;_id&lt;/code&gt; contains the Id of the index record.
 * <span class="attrib">@param</span> {Boolean} force (optional) If true the removal is done instantly.
 * In this case no checking is done if the index is locked, so use
 * this option with caution as it might lead to index corruption.
 */</span>
jala.IndexManager.<span class="reserved">prototype</span>.remove = <span class="reserved">function</span>(id, force) {
   <span class="reserved">if</span> (force === true) {
      var start = new Date();
      <span class="reserved">this</span>.getIndex().removeDocument(<span class="literal">"id"</span>, id);
      app.logger.debug(<span class="literal">"IndexManager '"</span> + <span class="reserved">this</span>.getName() +
                       <span class="literal">"': removed document with Id "</span> + id +
                       <span class="literal">" from index in "</span> + jala.IndexManager.getRuntime(start) +
                       <span class="literal">" ms"</span>);
   } <span class="reserved">else</span> {
      id = parseInt(id, 10);
      <span class="reserved">if</span> (isNaN(id)) {
         app.logger.error(<span class="literal">"IndexManager '"</span> + <span class="reserved">this</span>.getName() +
                          <span class="literal">"': missing or invalid document id to remove"</span>);
      } <span class="reserved">else</span> {
         var job = new jala.IndexManager.Job(jala.IndexManager.Job.REMOVE, id);
         <span class="reserved">this</span>.getQueue().add(job);
         app.logger.debug(<span class="literal">"IndexManager '"</span> + <span class="reserved">this</span>.getName() +
                          <span class="literal">"': queued removal of document with Id "</span> + id);
         <span class="reserved">if</span> (!<span class="reserved">this</span>.isRebuilding()) {
            <span class="reserved">this</span>.startWorker();
         }
      }
   }
   <span class="reserved">return</span>;
};

<span class="comment">/**
 * Optimizes the underlying index. Optimizing is done asynchronously,
 * so this method returns immediately, but the job itself will be
 * processed as soon as possible. Calling this method multiple times
 * doesn not lead to multiple optimization, as the job cannot be
 * added to the queue if there is already one.
 * <span class="attrib">@param</span> {Boolean} force If true the index is optimized
 * immediately, without any check whether the index is locked
 * or not, so use this option with caution.
 * <span class="attrib">@see</span> #needsOptimize()
 */</span>
jala.IndexManager.<span class="reserved">prototype</span>.optimize = <span class="reserved">function</span>(force) {
   <span class="reserved">if</span> (force === true) {
      var start = new Date();
      <span class="reserved">this</span>.getIndex().optimize();
      <span class="comment">// update version number to current index version</span>
      <span class="reserved">this</span>.updateVersion();
      app.logger.info(<span class="literal">"IndexManager '"</span> + <span class="reserved">this</span>.getName() +
                      <span class="literal">"': optimized index in "</span> + jala.IndexManager.getRuntime(start) +
                      <span class="literal">" ms"</span>);
   } <span class="reserved">else</span> {
      var job = new jala.IndexManager.Job(jala.IndexManager.Job.OPTIMIZE);
      <span class="reserved">this</span>.getQueue().add(job);
      app.logger.debug(<span class="literal">"IndexManager '"</span> + <span class="reserved">this</span>.getName() +
                       <span class="literal">"': queued index optimization"</span>);
      <span class="reserved">if</span> (!<span class="reserved">this</span>.isRebuilding()) {
         <span class="reserved">this</span>.startWorker();
      }
   }
   <span class="reserved">return</span>;
};

<span class="comment">/**
 * Returns the version number of the underlying index.
 * <span class="attrib">@returns</span> The current version number of the underlying index.
 * <span class="attrib">@type</span> Number
 */</span>
jala.IndexManager.<span class="reserved">prototype</span>.getCurrentIndexVersion = <span class="reserved">function</span>() {
   var dir = <span class="reserved">this</span>.getIndex().getDirectory();
   try {
      <span class="reserved">return</span> Packages.org.apache.lucene.index.IndexReader.getCurrentVersion(dir);
   } catch (e) {
      app.logger.debug(<span class="literal">"IndexManager '"</span> + <span class="reserved">this</span>.getName() +
                       <span class="literal">"': unable to determine the index version, reason: "</span> + e);
   }
   <span class="reserved">return</span> null;
};

<span class="comment">/**
 * Returns true if the index should be optimized. This is done by
 * comparing the version number of this IndexManager with the one of
 * the underlying index. If it exceeds IndexManager.OPTIMIZE_INTERVAL
 * the index needs to be optimized.
 * <span class="attrib">@returns</span> True in case the underlying should be optimized, false
 * otherwise
 * <span class="attrib">@type</span> Boolean
 */</span>
jala.IndexManager.<span class="reserved">prototype</span>.needsOptimize = <span class="reserved">function</span>() {
   var version = <span class="reserved">this</span>.getVersion();
   var indexVersion = <span class="reserved">this</span>.getCurrentIndexVersion();
   <span class="reserved">if</span> (indexVersion != null &amp;&amp;
      (indexVersion - version) &gt;= jala.IndexManager.OPTIMIZE_INTERVAL) {
      <span class="reserved">return</span> true;
   }
   <span class="reserved">return</span> false;
};

<span class="comment">/**
 * Flushes the underlying queue. This method should not be called
 * directly as it might run for a long time (depends on the length
 * of the queue). Instead this method will be executed asynchronously
 * after calling add(), remove() or optimize(). For safety reasons
 * every flush() will only run for a maximum time of 5 minutes, if
 * after that any objects are left in the queue a new asynchronous
 * thread will be started to continue processing the queue.
 * <span class="attrib">@private</span>
 */</span>
jala.IndexManager.<span class="reserved">prototype</span>.flush = <span class="reserved">function</span>() {
   var queue = <span class="reserved">this</span>.getQueue();
   var start = new Date();
   var job;
   <span class="reserved">while</span> (!queue.isEmpty() &amp;&amp; jala.IndexManager.getRuntime(start) &lt; 300000) {
      job = queue.remove(0);
      app.logger.debug(<span class="literal">"IndexManager '"</span> + <span class="reserved">this</span>.getName() +
                       <span class="literal">"': "</span> + job.type + <span class="literal">" job with Id "</span> + job.getId() +
                       <span class="literal">" has been in queue for "</span> + jala.IndexManager.getRuntime(job.createtime) +
                       <span class="literal">" ms, processing now... (Thread "</span> + java.lang.Thread.currentThread().getId() +
                       <span class="literal">", remaining jobs: "</span> + queue.size() + <span class="literal">")"</span>);
      try {
         switch (job.type) {
            case jala.IndexManager.Job.ADD:
               <span class="reserved">this</span>.add(job.data, true);
               break;

            case jala.IndexManager.Job.REMOVE:
               <span class="reserved">this</span>.remove(job.data, true);
               break;

            case jala.IndexManager.Job.OPTIMIZE:
               <span class="reserved">this</span>.optimize(true);
               break;

            default:
               app.logger.error(<span class="literal">"IndexManager '"</span> + <span class="reserved">this</span>.getName() +
                                <span class="literal">"': error during queue flush, unknown job type "</span> +
                                job.type);
               break;
         }
      } catch (e) {
         app.logger.debug(<span class="literal">"Exception during flush: "</span> + e);
         <span class="reserved">if</span> (job.errors &lt; jala.IndexManager.MAXTRIES) {
            <span class="comment">// got an error, so increment error counter and put back into queue</span>
            job.errors += 1;
            queue.add(job);
         } <span class="reserved">else</span> {
            app.logger.error(<span class="literal">"IndexManager '"</span> + <span class="reserved">this</span>.getName() +
                             <span class="literal">"': error during queue flush: tried "</span> +
                             jala.IndexManager.MAXTRIES + <span class="literal">" times to handle "</span> +
                             job.type + <span class="literal">" (Id: "</span> + job.getId() +
                             <span class="literal">", giving up. Last error was: "</span> + e);
         }
      }
   }
   <span class="reserved">if</span> (queue.size() &gt; 0) {
      <span class="comment">// there are still objects in the queue, so spawn a new worker</span>
      <span class="reserved">this</span>.startWorker(true);
   } <span class="reserved">else</span> <span class="reserved">if</span> (<span class="reserved">this</span>.needsOptimize()) {
      <span class="comment">// we're finished with flushing, but index needs an optimize</span>
      <span class="comment">// so add an optimizing job and start a new worker, but before</span>
      <span class="comment">// remove the reference to the worker to ensure that a new worker</span>
      <span class="comment">// is started (otherwise this worker would prevent the next</span>
      <span class="comment">// from starting).</span>
      queue.add(new jala.IndexManager.Job(jala.IndexManager.Job.OPTIMIZE));
      <span class="reserved">this</span>.startWorker(true);
   }
   <span class="reserved">return</span>;
};

<span class="comment">/**
 * Creates a new Job instance.
 * <span class="attrib">@class</span> Instances of this class represent a single index
 * manipulation job to be processed by the index manager.
 * <span class="attrib">@param</span> {Number} type The type of job, which can be either
 * jala.IndexManager.Job.ADD, jala.IndexManager.Job.REMOVE
 * or jala.IndexManager.Job.OPTIMIZE.
 * <span class="attrib">@param</span> {Object} data The data needed to process the job.
 * <span class="attrib">@returns</span> A newly created Job instance.
 * <span class="attrib">@constructor</span>
 * <span class="attrib">@see</span> jala.IndexManager.Job
 */</span>
jala.IndexManager.Job = <span class="reserved">function</span>(type, data) {
   <span class="comment">/**
    * The type of the job
    * <span class="attrib">@type</span> Number
    */</span>
   <span class="reserved">this</span>.type = type;

   <span class="comment">/**
    * The data needed to process this job. For adding jobs this property
    * must contain the {<span class="attrib">@link</span> helma.Search.Document} instance to add to
    * the index. For removal job this property must contain the unique identifier
    * of the document that should be removed from the index. For optimizing
    * jobs this property is null.
    */</span>
   <span class="reserved">this</span>.data = data;

   <span class="comment">/**
    * An internal error counter which is increased whenever processing
    * the job failed.
    * <span class="attrib">@type</span> Number
    * <span class="attrib">@see</span> jala.IndexManager.MAXTRIES
    */</span>
   <span class="reserved">this</span>.errors = 0;
   
   <span class="comment">/**
    * The date and time at which this job was created.
    * <span class="attrib">@type</span> Date
    */</span>
   <span class="reserved">this</span>.createtime = new Date();

   <span class="reserved">return</span> <span class="reserved">this</span>;
};

<span class="comment">/** <span class="attrib">@ignore</span> */</span>
jala.IndexManager.Job.<span class="reserved">prototype</span>.toString = <span class="reserved">function</span>() {
   <span class="reserved">return</span> <span class="literal">"[Index Job]"</span>;
};

<span class="comment">/**
 * Returns the Id of the job. For adding jobs, this returns the
 * Id of the document object, for removal jobs the Id to remove
 * from the index. For optimizing jobs this method returns null.
 * <span class="attrib">@returns</span> The Id of the job
 * <span class="attrib">@type</span> String
 */</span>
jala.IndexManager.Job.<span class="reserved">prototype</span>.getId = <span class="reserved">function</span>() {
   switch (<span class="reserved">this</span>.type) {
      case jala.IndexManager.Job.REMOVE:
         <span class="reserved">return</span> <span class="reserved">this</span>.data;
      case jala.IndexManager.Job.ADD:
         <span class="reserved">return</span> jala.IndexManager.getDocumentId(<span class="reserved">this</span>.data);
      default:
         break;
   }
   <span class="reserved">return</span> null;
};

<span class="comment">/**
 * Constant defining an add job
 * <span class="attrib">@type</span> Number
 * <span class="attrib">@final</span>
 */</span>
jala.IndexManager.Job.ADD = <span class="literal">"add"</span>;

<span class="comment">/**
 * Constant defining a removal job
 * <span class="attrib">@type</span> Number
 * <span class="attrib">@final</span>
 */</span>
jala.IndexManager.Job.REMOVE = <span class="literal">"remove"</span>;

<span class="comment">/**
 * Constant defining an optimizing job
 * <span class="attrib">@type</span> Number
 * <span class="attrib">@final</span>
 */</span>
jala.IndexManager.Job.OPTIMIZE = <span class="literal">"optimize"</span>;

</pre>
	<hr>



<!-- ========== START OF NAVBAR ========== -->
<a name="navbar_top"><!-- --></a>
<table border="0" width="100%" cellpadding="1" cellspacing="0">
<tr>
<td colspan=2 bgcolor="#EEEEFF" class="NavBarCell1">
<a name="navbar_top_firstrow"><!-- --></a>
<table border="0" cellpadding="0" cellspacing="3">
  <tr align="center" valign="top">
  
  
  <td bgcolor="#EEEEFF" class="NavBarCell1">    <a href="overview-summary.html"><font class="NavBarFont1"><b>Overview</b></font></a>&nbsp;</td>
  <td bgcolor="#FFFFFF" class="NavBarCell1Rev">	&nbsp;<font class="NavBarFont1Rev"><b>File</b></font>&nbsp;</td>
  

  <td bgcolor="#FFFFFF" class="NavBarCell1"> <font class="NavBarFont1">Class</font>&nbsp;</td>
  <td bgcolor="#EEEEFF" class="NavBarCell1">    <a href="overview-tree.html"><font class="NavBarFont1"><b>Tree</b></font></a>&nbsp;</td>
  <td bgcolor="#EEEEFF" class="NavBarCell1">    <a href="index-all.html"--><font class="NavBarFont1"><b>Index</b></font></a>&nbsp;</td>
  <td bgcolor="#EEEEFF" class="NavBarCell1">    <a href="help-doc.html"><font class="NavBarFont1"><b>Help</b></font></a>&nbsp;</td>
  </tr>
</table>
</td>
<td bgcolor="#EEEEFF" align="right" valign="top"><em>
<b>Jala 1.0</b></em>
</td>
</tr>

<tr>
<td bgcolor="white" class="NavBarCell2"><font size="-2">
&nbsp;PREV&nbsp;
&nbsp;NEXT</font></td>
<td bgcolor="white" class="NavBarCell2"><font size="-2">
  <a href="index.html" target="_top"><b>FRAMES</b></a>  &nbsp;
&nbsp;<a href="overview-summary.html" target="_top"><b>NO FRAMES</b></a>
&nbsp;&nbsp;
<script>
  <!--
  if(window==top) {
    document.writeln('<A HREF="allclasses-noframe.html" TARGET=""><B>All Classes</B></A>');
  }
  //-->
</script>
<noscript>
<a href="allclasses-noframe.html" target=""><b>All Classes</b></a>
</noscript>
</font></td>
</tr>
</table>
<!-- =========== END OF NAVBAR =========== -->

<hr>
<font size="-1">

</font>
<div class="jsdoc_ctime">Documentation generated by <a href="http://jsdoc.sourceforge.net/" target="_parent">JSDoc</a> on Thu Mar  1 09:40:28 2007</div>
</body>
</html>
